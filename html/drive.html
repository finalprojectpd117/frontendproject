<!-- 포즈를 구현해보려 했으나 한 곳에 구현은 실패 일단 따로 따로 구현.-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />

    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils_3d/control_utils_3d.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"
      crossorigin="anonymous"
    ></script>

    <title>운전자 상태(포즈)</title>
    <style>
      #container {
        margin: 0pxauto;
        width: 500px;
        height: 375px;
        border: 10px #333 solid;
      }
      #videoElement {
        width: 500px;
        height: 375px;
        background-color: #666;
      }
      /*.hide {
        display: none;
      } 타이머 숨기기 기능*/
    </style>
  </head>

  <body>
    <div id="container">
      <video class="input_video" width="500px" height="375px"></video>
      <canvas class="output_canvas" width="500px" height="375px"></canvas>
      <div class="landmark-grid-container"></div>
    </div>

    <div>운전자 상태<br /></div>

    <div>
      <span class="timer drive-timer">00:00:00</span>
      <br />
      <input class="drive-timer_startBtn" type="button" value="주행 시작" />
      <input class="drive-timer_stopBtn" type="button" value="주행 종료" />
      <button href="main.jsp">메인 메뉴</button>
    </div>

    <script>
      var video = document.querySelector("#videoElement");
      const videoElement = document.getElementsByClassName("input_video")[0];
      const canvasElement = document.getElementsByClassName("output_canvas")[0];
      const canvasCtx = canvasElement.getContext("2d");
      const landmarkContainer = document.getElementsByClassName(
        "landmark-grid-container"
      )[0];
      const grid = new LandmarkGrid(landmarkContainer);

      function onResults(results) {
        if (!results.poseLandmarks) {
          grid.updateLandmarks([]);
          return;
        }

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(
          results.segmentationMask,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );

        // Only overwrite existing pixels.
        canvasCtx.globalCompositeOperation = "source-in";
        canvasCtx.fillStyle = "#00FF00";
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        // Only overwrite missing pixels.
        canvasCtx.globalCompositeOperation = "destination-atop";
        canvasCtx.drawImage(
          results.image,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );

        canvasCtx.globalCompositeOperation = "source-over";
        drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {
          color: "#00FF00",
          lineWidth: 4,
        });
        drawLandmarks(canvasCtx, results.poseLandmarks, {
          color: "#FF0000",
          lineWidth: 2,
        });
        canvasCtx.restore();

        grid.updateLandmarks(results.poseWorldLandmarks);
      }

      const pose = new Pose({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        },
      });
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: true,
        smoothSegmentation: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      pose.onResults(onResults);

      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await pose.send({ image: videoElement });
        },
        width: 500,
        height: 375,
      });
      camera.start();

      if (navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then(function (stream) {
            video.srcObject = stream;
          })
          .catch(function (err0r) {
            console.log("Something went wrong!");
          });
      }
      const timer = document.querySelector(".drive-timer"),
        startBtn = document.querySelector(".drive-timer_startBtn"),
        stopBtn = document.querySelector(".drive-timer_stopBtn");

      let TIME = 0;
      let cron;

      function startButton() {
        updateTimer();
        stopButton();
        cron = setInterval(updateTimer, 1000);
        timer.classList.add("hide");
      }
      function stopButton() {
        clearInterval(cron);
        timer.classList.remove("hide");
      }

      function updateTimer() {
        const hours = Math.floor(TIME / 3600);
        const checkMinutes = Math.floor(TIME / 60);
        const seconds = TIME % 60;
        const minutes = checkMinutes % 60;

        timer.innerText = `${hours < 10 ? `0${hours}` : hours}:${
          minutes < 10 ? `0${minutes}` : minutes
        }:${seconds < 10 ? `0${seconds}` : seconds}`;
        TIME++;
      }
      startBtn.addEventListener("click", startButton);
      stopBtn.addEventListener("click", stopButton);
    </script>
  </body>
</html>
